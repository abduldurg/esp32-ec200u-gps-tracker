#include <HardwareSerial.h>
#include "mbedtls/base64.h"

// === Pin config ===
#define MODEM_RX 18       // EC200U TX -> ESP32 RX
#define MODEM_TX 17       // EC200U RX <- ESP32 TX
#define PWRKEY   10       // EC200U PWRKEY -> ESP32 GPIO10

HardwareSerial modem(1);  // UART1 for EC200U

// === Variables ===
String latitude = "", longitude = "", timestamp = "", accuracy = "";
String prevLat = "", prevLon = "";
String deviceID = "";
String vehicleNumber = "OXY12345";   // fixed VehNo

// === Auth credentials ===
String authUser = "username";
String authPass = "pass";

// ===== PWRKEY Pulse =====
void pulsePowerKey() {
  pinMode(PWRKEY, OUTPUT);
  digitalWrite(PWRKEY, LOW);
  delay(1200);
  digitalWrite(PWRKEY, HIGH);
  delay(100);
  pinMode(PWRKEY, INPUT);
  Serial.println("üîã PWRKEY pulsed, waiting for modem...");
}

// ===== Base64 Auth =====
String getAuthHeader() {
  String authRaw = authUser + ":" + authPass;
  size_t out_len;
  size_t input_len = authRaw.length();
  size_t buf_len = ((input_len + 2) / 3) * 4 + 4;
  char *output = new char[buf_len];
  mbedtls_base64_encode((unsigned char*)output, buf_len, &out_len,
                        (const unsigned char*)authRaw.c_str(), input_len);
  output[out_len] = '\0';
  String authHeader = "Authorization: Basic " + String(output);
  delete[] output;
  return authHeader;
}

// ===== AT command helper =====
String sendAT(String cmd, int timeout = 3000) {
  if (cmd != "") {
    modem.print(cmd);
    modem.print("\r");
  }
  unsigned long start = millis();
  String resp = "";
  while (millis() - start < timeout) {
    while (modem.available()) {
      resp += (char)modem.read();
    }
  }
  if (cmd != "") Serial.println("> " + cmd);
  if (resp != "") Serial.println(resp);
  return resp;
}

// ===== Wait for network registration =====
bool waitForNetwork(int timeoutSec = 30) {
  unsigned long start = millis();
  while ((millis() - start) < (timeoutSec * 1000UL)) {
    String r = sendAT("AT+CREG?");
    if (r.indexOf(",1") != -1 || r.indexOf(",5") != -1) return true;
    delay(1000);
  }
  return false;
}

// ===== Activate PDP context with retry =====
bool activatePDP(int retries = 5) {
  for (int i = 0; i < retries; i++) {
    String resp = sendAT("AT+QIACT=1", 10000);
    if (resp.indexOf("OK") != -1) return true;
    Serial.println("‚ùå PDP activation failed, retrying...");
    delay(3000);
  }
  return false;
}

// ===== Send to server via HTTPS GET =====
void sendToServer(String lat, String lon, String tsm, String acc, String id, String vno) {
  String filter = "(VehNo eq '" + vno + "' and " +
                  "DeviceID eq '" + id + "' and " +
                  "EntryTime eq '" + tsm + "' and " +
                  "Latitude eq '" + lat + "' and " +
                  "Longitude eq '" + lon + "' and " +
                  "Accuracy eq '" + acc + "')";
  
  filter.replace(" ", "%20");
  filter.replace("'", "%27");

  String path = "full path" + filter;
  String host = "yourserver.com";
  String url = "https://" + host + path;

  Serial.println("‚û°Ô∏è HTTPS GET: " + url);

  // === Configure URL ===
  sendAT("AT+QHTTPURL=" + String(url.length()) + ",80", 5000);
  delay(100);
  modem.print(url);
  modem.write(0x1A);  // Ctrl+Z
  sendAT("", 5000);

  // === Build full HTTP request header (manual mode) ===
  String authHeader = getAuthHeader();
  String header = "GET " + path + " HTTP/1.1\r\n";
  header += "Host: " + host + "\r\n";
  header += authHeader + "\r\n";
  header += "Accept: application/xml\r\n";
  header += "Connection: close\r\n\r\n";

  Serial.println("üîë Sending full HTTP GET request:");
  Serial.println(header);

  // === Send GET with headers ===
  String resp = sendAT("AT+QHTTPGET=80," + String(header.length()), 5000);
  if (resp.indexOf("CONNECT") != -1) {
    modem.print(header);
    modem.write(0x1A);  // End with Ctrl+Z
    Serial.println("üì§ Headers sent.");
  } else {
    Serial.println("‚ùå Failed to start QHTTPGET");
    return;
  }

  // === Wait for GET response ===
  resp = sendAT("", 20000);
  Serial.println("üì° HTTPS GET Resp: " + resp);

  // Parse status code
  int idx = resp.indexOf("+QHTTPGET:");
  if (idx != -1) {
    int c1 = resp.indexOf(',', idx);
    int c2 = resp.indexOf(',', c1 + 1);
    String code = resp.substring(c1 + 1, c2);
    Serial.println("üîé HTTP Status: " + code);
  }

  // === Read server response body ===
  resp = sendAT("AT+QHTTPREAD=80", 20000);
  Serial.println("üì• Server Response: " + resp);
}

// ===== Setup =====
void setup() {
  Serial.begin(115200);
  modem.begin(115200, SERIAL_8N1, MODEM_RX, MODEM_TX);

  Serial.println("=== EC200U HTTPS + GNSS ===");

  // Unique ESP32 ID
  uint64_t chipid = ESP.getEfuseMac();
  char chipString[17];
  sprintf(chipString, "%04X%08X", (uint16_t)(chipid >> 32), (uint32_t)chipid);
  deviceID = String(chipString);
  Serial.println("Device ID: " + deviceID);

  pulsePowerKey();
  delay(4000);

  sendAT("AT");
  sendAT("AT+CPIN?");
  sendAT("AT+CSQ");
  sendAT("AT+CFUN=1");
  sendAT("AT+CGATT=1");
  sendAT("AT+CGMR");
  sendAT("AT+QICSGP=1,1,\"airtelgprs.com\",\"\",\"\",1");

  if (!waitForNetwork()) {
    Serial.println("‚ùå Network not registered, stopping.");
    while (1);
  }

  if (!activatePDP()) {
    Serial.println("‚ùå PDP context failed, stopping.");
    while (1);
  }

  // === Enable HTTPS / SSL ===
  sendAT("AT+QHTTPCFG=\"contextid\",1");     // use PDP context 1
  sendAT("AT+QHTTPCFG=\"sslctxid\",1");     // bind SSL context
  sendAT("AT+QSSLCFG=\"sslversion\",1,3");  // TLS 1.2
  sendAT("AT+QSSLCFG=\"seclevel\",1,0");    // skip cert check
  sendAT("AT+QHTTPCFG=\"requestheader\",1");// manual header mode

  Serial.println("‚úÖ PDP + HTTPS config ready.");
  sendAT("AT+QGPS=1");
}

// ===== Loop =====
void loop() {
  String resp = sendAT("AT+QGPSLOC=2", 4000);
  if (resp.indexOf("+QGPSLOC:") != -1) {
    int idx = resp.indexOf("+QGPSLOC:");
    String data = resp.substring(idx + 9);
    data.trim();

    int p = 0; String parts[12];
    for (int i = 0; i < 12; i++) {
      int c = data.indexOf(',', p);
      if (c == -1) { parts[i] = data.substring(p); break; }
      parts[i] = data.substring(p, c);
      p = c + 1;
    }

    timestamp = parts[0];
    latitude  = parts[1];
    longitude = parts[2];
    accuracy  = parts[3];

    Serial.println("Lat: " + latitude + " Lon: " + longitude + " Acc: " + accuracy);

    if (latitude != "" && longitude != "" &&
        (latitude != prevLat || longitude != prevLon)) {
      sendToServer(latitude, longitude, timestamp, accuracy, deviceID, vehicleNumber);
      prevLat = latitude;
      prevLon = longitude;
    }
  }
  delay(30000);
}
